// Code generated by BobGen sqlite v0.28.1. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"hash/maphash"

	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/clause"
	"github.com/stephenafamo/bob/dialect/sqlite"
	"github.com/stephenafamo/bob/dialect/sqlite/dialect"
)

var TableNames = struct {
	Auths           string
	Days            string
	DeepWorkLogs    string
	FitnessLogs     string
	HabitCategories string
	HabitLogs       string
	Habits          string
	SleepLogs       string
	Users           string
}{
	Auths:           "auths",
	Days:            "days",
	DeepWorkLogs:    "deep_work_logs",
	FitnessLogs:     "fitness_logs",
	HabitCategories: "habit_categories",
	HabitLogs:       "habit_logs",
	Habits:          "habits",
	SleepLogs:       "sleep_logs",
	Users:           "users",
}

var ColumnNames = struct {
	Auths           authColumnNames
	Days            dayColumnNames
	DeepWorkLogs    deepWorkLogColumnNames
	FitnessLogs     fitnessLogColumnNames
	HabitCategories habitCategoryColumnNames
	HabitLogs       habitLogColumnNames
	Habits          habitColumnNames
	SleepLogs       sleepLogColumnNames
	Users           userColumnNames
}{
	Auths: authColumnNames{
		ID:           "id",
		Provider:     "provider",
		AccessToken:  "access_token",
		RefreshToken: "refresh_token",
		TokenType:    "token_type",
		Expiration:   "expiration",
	},
	Days: dayColumnNames{
		ID:   "id",
		Date: "date",
	},
	DeepWorkLogs: deepWorkLogColumnNames{
		ID:          "id",
		DayID:       "day_id",
		Date:        "date",
		Seconds:     "seconds",
		IsAutomated: "is_automated",
		Origin:      "origin",
	},
	FitnessLogs: fitnessLogColumnNames{
		ID:        "id",
		DayID:     "day_id",
		Date:      "date",
		StartTime: "start_time",
		EndTime:   "end_time",
		Type:      "type",
		Title:     "title",
		Origin:    "origin",
		Note:      "note",
		Raw:       "raw",
	},
	HabitCategories: habitCategoryColumnNames{
		ID:          "id",
		Name:        "name",
		Type:        "type",
		Description: "description",
	},
	HabitLogs: habitLogColumnNames{
		ID:          "id",
		HabitID:     "habit_id",
		Origin:      "origin",
		Success:     "success",
		IsAutomated: "is_automated",
		Detail:      "detail",
	},
	Habits: habitColumnNames{
		ID:              "id",
		DayID:           "day_id",
		HabitCategoryID: "habit_category_id",
		State:           "state",
	},
	SleepLogs: sleepLogColumnNames{
		ID:             "id",
		DayID:          "day_id",
		Date:           "date",
		StartTime:      "start_time",
		EndTime:        "end_time",
		IsMainSleep:    "is_main_sleep",
		IsAutomated:    "is_automated",
		Origin:         "origin",
		TotalTimeInBed: "total_time_in_bed",
		MinutesAsleep:  "minutes_asleep",
		MinutesRem:     "minutes_rem",
		MinutesDeep:    "minutes_deep",
		MinutesLight:   "minutes_light",
		MinutesAwake:   "minutes_awake",
		Raw:            "raw",
	},
	Users: userColumnNames{
		ID:       "id",
		Username: "username",
		Password: "password",
		Role:     "role",
		Email:    "email",
	},
}

var (
	SelectWhere = Where[*dialect.SelectQuery]()
	InsertWhere = Where[*dialect.InsertQuery]()
	UpdateWhere = Where[*dialect.UpdateQuery]()
	DeleteWhere = Where[*dialect.DeleteQuery]()
)

func Where[Q sqlite.Filterable]() struct {
	Auths           authWhere[Q]
	Days            dayWhere[Q]
	DeepWorkLogs    deepWorkLogWhere[Q]
	FitnessLogs     fitnessLogWhere[Q]
	HabitCategories habitCategoryWhere[Q]
	HabitLogs       habitLogWhere[Q]
	Habits          habitWhere[Q]
	SleepLogs       sleepLogWhere[Q]
	Users           userWhere[Q]
} {
	return struct {
		Auths           authWhere[Q]
		Days            dayWhere[Q]
		DeepWorkLogs    deepWorkLogWhere[Q]
		FitnessLogs     fitnessLogWhere[Q]
		HabitCategories habitCategoryWhere[Q]
		HabitLogs       habitLogWhere[Q]
		Habits          habitWhere[Q]
		SleepLogs       sleepLogWhere[Q]
		Users           userWhere[Q]
	}{
		Auths:           buildAuthWhere[Q](AuthColumns),
		Days:            buildDayWhere[Q](DayColumns),
		DeepWorkLogs:    buildDeepWorkLogWhere[Q](DeepWorkLogColumns),
		FitnessLogs:     buildFitnessLogWhere[Q](FitnessLogColumns),
		HabitCategories: buildHabitCategoryWhere[Q](HabitCategoryColumns),
		HabitLogs:       buildHabitLogWhere[Q](HabitLogColumns),
		Habits:          buildHabitWhere[Q](HabitColumns),
		SleepLogs:       buildSleepLogWhere[Q](SleepLogColumns),
		Users:           buildUserWhere[Q](UserColumns),
	}
}

var (
	SelectJoins = getJoins[*dialect.SelectQuery]
	UpdateJoins = getJoins[*dialect.UpdateQuery]
)

type joinSet[Q interface{ aliasedAs(string) Q }] struct {
	InnerJoin Q
	LeftJoin  Q
	RightJoin Q
}

func (j joinSet[Q]) AliasedAs(alias string) joinSet[Q] {
	return joinSet[Q]{
		InnerJoin: j.InnerJoin.aliasedAs(alias),
		LeftJoin:  j.LeftJoin.aliasedAs(alias),
		RightJoin: j.RightJoin.aliasedAs(alias),
	}
}

type joins[Q dialect.Joinable] struct {
	Days            joinSet[dayJoins[Q]]
	DeepWorkLogs    joinSet[deepWorkLogJoins[Q]]
	FitnessLogs     joinSet[fitnessLogJoins[Q]]
	HabitCategories joinSet[habitCategoryJoins[Q]]
	HabitLogs       joinSet[habitLogJoins[Q]]
	Habits          joinSet[habitJoins[Q]]
	SleepLogs       joinSet[sleepLogJoins[Q]]
}

func buildJoinSet[Q interface{ aliasedAs(string) Q }, C any, F func(C, string) Q](c C, f F) joinSet[Q] {
	return joinSet[Q]{
		InnerJoin: f(c, clause.InnerJoin),
		LeftJoin:  f(c, clause.LeftJoin),
		RightJoin: f(c, clause.RightJoin),
	}
}

func getJoins[Q dialect.Joinable]() joins[Q] {
	return joins[Q]{
		Days:            buildJoinSet[dayJoins[Q]](DayColumns, buildDayJoins),
		DeepWorkLogs:    buildJoinSet[deepWorkLogJoins[Q]](DeepWorkLogColumns, buildDeepWorkLogJoins),
		FitnessLogs:     buildJoinSet[fitnessLogJoins[Q]](FitnessLogColumns, buildFitnessLogJoins),
		HabitCategories: buildJoinSet[habitCategoryJoins[Q]](HabitCategoryColumns, buildHabitCategoryJoins),
		HabitLogs:       buildJoinSet[habitLogJoins[Q]](HabitLogColumns, buildHabitLogJoins),
		Habits:          buildJoinSet[habitJoins[Q]](HabitColumns, buildHabitJoins),
		SleepLogs:       buildJoinSet[sleepLogJoins[Q]](SleepLogColumns, buildSleepLogJoins),
	}
}

type modAs[Q any, C interface{ AliasedAs(string) C }] struct {
	c C
	f func(C) bob.Mod[Q]
}

func (m modAs[Q, C]) Apply(q Q) {
	m.f(m.c).Apply(q)
}

func (m modAs[Q, C]) AliasedAs(alias string) bob.Mod[Q] {
	m.c = m.c.AliasedAs(alias)
	return m
}

func randInt() int64 {
	out := int64(new(maphash.Hash).Sum64())

	if out < 0 {
		return -out % 10000
	}

	return out % 10000
}
