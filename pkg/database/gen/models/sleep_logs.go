// Code generated by BobGen sqlite v0.28.1. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"time"

	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/sqlite"
	"github.com/stephenafamo/bob/dialect/sqlite/dialect"
	"github.com/stephenafamo/bob/dialect/sqlite/im"
	"github.com/stephenafamo/bob/dialect/sqlite/sm"
	"github.com/stephenafamo/bob/dialect/sqlite/um"
	"github.com/stephenafamo/bob/expr"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
)

// SleepLog is an object representing the database table.
type SleepLog struct {
	ID             int32            `db:"id,pk" `
	DayID          int32            `db:"day_id" `
	Date           time.Time        `db:"date" `
	StartTime      time.Time        `db:"start_time" `
	EndTime        time.Time        `db:"end_time" `
	IsMainSleep    null.Val[bool]   `db:"is_main_sleep" `
	IsAutomated    null.Val[bool]   `db:"is_automated" `
	Origin         string           `db:"origin" `
	TotalTimeInBed null.Val[int32]  `db:"total_time_in_bed" `
	MinutesAsleep  null.Val[int32]  `db:"minutes_asleep" `
	MinutesRem     null.Val[int32]  `db:"minutes_rem" `
	MinutesDeep    null.Val[int32]  `db:"minutes_deep" `
	MinutesLight   null.Val[int32]  `db:"minutes_light" `
	MinutesAwake   null.Val[int32]  `db:"minutes_awake" `
	Raw            null.Val[string] `db:"raw" `

	R sleepLogR `db:"-" `
}

// SleepLogSlice is an alias for a slice of pointers to SleepLog.
// This should almost always be used instead of []*SleepLog.
type SleepLogSlice []*SleepLog

// SleepLogs contains methods to work with the sleep_logs table
var SleepLogs = sqlite.NewTablex[*SleepLog, SleepLogSlice, *SleepLogSetter]("", "sleep_logs")

// SleepLogsQuery is a query on the sleep_logs table
type SleepLogsQuery = *sqlite.ViewQuery[*SleepLog, SleepLogSlice]

// SleepLogsStmt is a prepared statment on sleep_logs
type SleepLogsStmt = bob.QueryStmt[*SleepLog, SleepLogSlice]

// sleepLogR is where relationships are stored.
type sleepLogR struct {
	Day *Day // fk_sleep_logs_0
}

// SleepLogSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type SleepLogSetter struct {
	ID             omit.Val[int32]      `db:"id,pk" `
	DayID          omit.Val[int32]      `db:"day_id" `
	Date           omit.Val[time.Time]  `db:"date" `
	StartTime      omit.Val[time.Time]  `db:"start_time" `
	EndTime        omit.Val[time.Time]  `db:"end_time" `
	IsMainSleep    omitnull.Val[bool]   `db:"is_main_sleep" `
	IsAutomated    omitnull.Val[bool]   `db:"is_automated" `
	Origin         omit.Val[string]     `db:"origin" `
	TotalTimeInBed omitnull.Val[int32]  `db:"total_time_in_bed" `
	MinutesAsleep  omitnull.Val[int32]  `db:"minutes_asleep" `
	MinutesRem     omitnull.Val[int32]  `db:"minutes_rem" `
	MinutesDeep    omitnull.Val[int32]  `db:"minutes_deep" `
	MinutesLight   omitnull.Val[int32]  `db:"minutes_light" `
	MinutesAwake   omitnull.Val[int32]  `db:"minutes_awake" `
	Raw            omitnull.Val[string] `db:"raw" `
}

func (s SleepLogSetter) SetColumns() []string {
	vals := make([]string, 0, 15)
	if !s.ID.IsUnset() {
		vals = append(vals, "id")
	}

	if !s.DayID.IsUnset() {
		vals = append(vals, "day_id")
	}

	if !s.Date.IsUnset() {
		vals = append(vals, "date")
	}

	if !s.StartTime.IsUnset() {
		vals = append(vals, "start_time")
	}

	if !s.EndTime.IsUnset() {
		vals = append(vals, "end_time")
	}

	if !s.IsMainSleep.IsUnset() {
		vals = append(vals, "is_main_sleep")
	}

	if !s.IsAutomated.IsUnset() {
		vals = append(vals, "is_automated")
	}

	if !s.Origin.IsUnset() {
		vals = append(vals, "origin")
	}

	if !s.TotalTimeInBed.IsUnset() {
		vals = append(vals, "total_time_in_bed")
	}

	if !s.MinutesAsleep.IsUnset() {
		vals = append(vals, "minutes_asleep")
	}

	if !s.MinutesRem.IsUnset() {
		vals = append(vals, "minutes_rem")
	}

	if !s.MinutesDeep.IsUnset() {
		vals = append(vals, "minutes_deep")
	}

	if !s.MinutesLight.IsUnset() {
		vals = append(vals, "minutes_light")
	}

	if !s.MinutesAwake.IsUnset() {
		vals = append(vals, "minutes_awake")
	}

	if !s.Raw.IsUnset() {
		vals = append(vals, "raw")
	}

	return vals
}

func (s SleepLogSetter) Overwrite(t *SleepLog) {
	if !s.ID.IsUnset() {
		t.ID, _ = s.ID.Get()
	}
	if !s.DayID.IsUnset() {
		t.DayID, _ = s.DayID.Get()
	}
	if !s.Date.IsUnset() {
		t.Date, _ = s.Date.Get()
	}
	if !s.StartTime.IsUnset() {
		t.StartTime, _ = s.StartTime.Get()
	}
	if !s.EndTime.IsUnset() {
		t.EndTime, _ = s.EndTime.Get()
	}
	if !s.IsMainSleep.IsUnset() {
		t.IsMainSleep, _ = s.IsMainSleep.GetNull()
	}
	if !s.IsAutomated.IsUnset() {
		t.IsAutomated, _ = s.IsAutomated.GetNull()
	}
	if !s.Origin.IsUnset() {
		t.Origin, _ = s.Origin.Get()
	}
	if !s.TotalTimeInBed.IsUnset() {
		t.TotalTimeInBed, _ = s.TotalTimeInBed.GetNull()
	}
	if !s.MinutesAsleep.IsUnset() {
		t.MinutesAsleep, _ = s.MinutesAsleep.GetNull()
	}
	if !s.MinutesRem.IsUnset() {
		t.MinutesRem, _ = s.MinutesRem.GetNull()
	}
	if !s.MinutesDeep.IsUnset() {
		t.MinutesDeep, _ = s.MinutesDeep.GetNull()
	}
	if !s.MinutesLight.IsUnset() {
		t.MinutesLight, _ = s.MinutesLight.GetNull()
	}
	if !s.MinutesAwake.IsUnset() {
		t.MinutesAwake, _ = s.MinutesAwake.GetNull()
	}
	if !s.Raw.IsUnset() {
		t.Raw, _ = s.Raw.GetNull()
	}
}

func (s SleepLogSetter) InsertMod() bob.Mod[*dialect.InsertQuery] {
	vals := make([]bob.Expression, 0, 15)
	if !s.ID.IsUnset() {
		vals = append(vals, sqlite.Arg(s.ID))
	}

	if !s.DayID.IsUnset() {
		vals = append(vals, sqlite.Arg(s.DayID))
	}

	if !s.Date.IsUnset() {
		vals = append(vals, sqlite.Arg(s.Date))
	}

	if !s.StartTime.IsUnset() {
		vals = append(vals, sqlite.Arg(s.StartTime))
	}

	if !s.EndTime.IsUnset() {
		vals = append(vals, sqlite.Arg(s.EndTime))
	}

	if !s.IsMainSleep.IsUnset() {
		vals = append(vals, sqlite.Arg(s.IsMainSleep))
	}

	if !s.IsAutomated.IsUnset() {
		vals = append(vals, sqlite.Arg(s.IsAutomated))
	}

	if !s.Origin.IsUnset() {
		vals = append(vals, sqlite.Arg(s.Origin))
	}

	if !s.TotalTimeInBed.IsUnset() {
		vals = append(vals, sqlite.Arg(s.TotalTimeInBed))
	}

	if !s.MinutesAsleep.IsUnset() {
		vals = append(vals, sqlite.Arg(s.MinutesAsleep))
	}

	if !s.MinutesRem.IsUnset() {
		vals = append(vals, sqlite.Arg(s.MinutesRem))
	}

	if !s.MinutesDeep.IsUnset() {
		vals = append(vals, sqlite.Arg(s.MinutesDeep))
	}

	if !s.MinutesLight.IsUnset() {
		vals = append(vals, sqlite.Arg(s.MinutesLight))
	}

	if !s.MinutesAwake.IsUnset() {
		vals = append(vals, sqlite.Arg(s.MinutesAwake))
	}

	if !s.Raw.IsUnset() {
		vals = append(vals, sqlite.Arg(s.Raw))
	}

	return im.Values(vals...)
}

func (s SleepLogSetter) Apply(q *dialect.UpdateQuery) {
	um.Set(s.Expressions()...).Apply(q)
}

func (s SleepLogSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 15)

	if !s.ID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			sqlite.Quote(append(prefix, "id")...),
			sqlite.Arg(s.ID),
		}})
	}

	if !s.DayID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			sqlite.Quote(append(prefix, "day_id")...),
			sqlite.Arg(s.DayID),
		}})
	}

	if !s.Date.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			sqlite.Quote(append(prefix, "date")...),
			sqlite.Arg(s.Date),
		}})
	}

	if !s.StartTime.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			sqlite.Quote(append(prefix, "start_time")...),
			sqlite.Arg(s.StartTime),
		}})
	}

	if !s.EndTime.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			sqlite.Quote(append(prefix, "end_time")...),
			sqlite.Arg(s.EndTime),
		}})
	}

	if !s.IsMainSleep.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			sqlite.Quote(append(prefix, "is_main_sleep")...),
			sqlite.Arg(s.IsMainSleep),
		}})
	}

	if !s.IsAutomated.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			sqlite.Quote(append(prefix, "is_automated")...),
			sqlite.Arg(s.IsAutomated),
		}})
	}

	if !s.Origin.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			sqlite.Quote(append(prefix, "origin")...),
			sqlite.Arg(s.Origin),
		}})
	}

	if !s.TotalTimeInBed.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			sqlite.Quote(append(prefix, "total_time_in_bed")...),
			sqlite.Arg(s.TotalTimeInBed),
		}})
	}

	if !s.MinutesAsleep.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			sqlite.Quote(append(prefix, "minutes_asleep")...),
			sqlite.Arg(s.MinutesAsleep),
		}})
	}

	if !s.MinutesRem.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			sqlite.Quote(append(prefix, "minutes_rem")...),
			sqlite.Arg(s.MinutesRem),
		}})
	}

	if !s.MinutesDeep.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			sqlite.Quote(append(prefix, "minutes_deep")...),
			sqlite.Arg(s.MinutesDeep),
		}})
	}

	if !s.MinutesLight.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			sqlite.Quote(append(prefix, "minutes_light")...),
			sqlite.Arg(s.MinutesLight),
		}})
	}

	if !s.MinutesAwake.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			sqlite.Quote(append(prefix, "minutes_awake")...),
			sqlite.Arg(s.MinutesAwake),
		}})
	}

	if !s.Raw.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			sqlite.Quote(append(prefix, "raw")...),
			sqlite.Arg(s.Raw),
		}})
	}

	return exprs
}

type sleepLogColumnNames struct {
	ID             string
	DayID          string
	Date           string
	StartTime      string
	EndTime        string
	IsMainSleep    string
	IsAutomated    string
	Origin         string
	TotalTimeInBed string
	MinutesAsleep  string
	MinutesRem     string
	MinutesDeep    string
	MinutesLight   string
	MinutesAwake   string
	Raw            string
}

var SleepLogColumns = buildSleepLogColumns("sleep_logs")

type sleepLogColumns struct {
	tableAlias     string
	ID             sqlite.Expression
	DayID          sqlite.Expression
	Date           sqlite.Expression
	StartTime      sqlite.Expression
	EndTime        sqlite.Expression
	IsMainSleep    sqlite.Expression
	IsAutomated    sqlite.Expression
	Origin         sqlite.Expression
	TotalTimeInBed sqlite.Expression
	MinutesAsleep  sqlite.Expression
	MinutesRem     sqlite.Expression
	MinutesDeep    sqlite.Expression
	MinutesLight   sqlite.Expression
	MinutesAwake   sqlite.Expression
	Raw            sqlite.Expression
}

func (c sleepLogColumns) Alias() string {
	return c.tableAlias
}

func (sleepLogColumns) AliasedAs(alias string) sleepLogColumns {
	return buildSleepLogColumns(alias)
}

func buildSleepLogColumns(alias string) sleepLogColumns {
	return sleepLogColumns{
		tableAlias:     alias,
		ID:             sqlite.Quote(alias, "id"),
		DayID:          sqlite.Quote(alias, "day_id"),
		Date:           sqlite.Quote(alias, "date"),
		StartTime:      sqlite.Quote(alias, "start_time"),
		EndTime:        sqlite.Quote(alias, "end_time"),
		IsMainSleep:    sqlite.Quote(alias, "is_main_sleep"),
		IsAutomated:    sqlite.Quote(alias, "is_automated"),
		Origin:         sqlite.Quote(alias, "origin"),
		TotalTimeInBed: sqlite.Quote(alias, "total_time_in_bed"),
		MinutesAsleep:  sqlite.Quote(alias, "minutes_asleep"),
		MinutesRem:     sqlite.Quote(alias, "minutes_rem"),
		MinutesDeep:    sqlite.Quote(alias, "minutes_deep"),
		MinutesLight:   sqlite.Quote(alias, "minutes_light"),
		MinutesAwake:   sqlite.Quote(alias, "minutes_awake"),
		Raw:            sqlite.Quote(alias, "raw"),
	}
}

type sleepLogWhere[Q sqlite.Filterable] struct {
	ID             sqlite.WhereMod[Q, int32]
	DayID          sqlite.WhereMod[Q, int32]
	Date           sqlite.WhereMod[Q, time.Time]
	StartTime      sqlite.WhereMod[Q, time.Time]
	EndTime        sqlite.WhereMod[Q, time.Time]
	IsMainSleep    sqlite.WhereNullMod[Q, bool]
	IsAutomated    sqlite.WhereNullMod[Q, bool]
	Origin         sqlite.WhereMod[Q, string]
	TotalTimeInBed sqlite.WhereNullMod[Q, int32]
	MinutesAsleep  sqlite.WhereNullMod[Q, int32]
	MinutesRem     sqlite.WhereNullMod[Q, int32]
	MinutesDeep    sqlite.WhereNullMod[Q, int32]
	MinutesLight   sqlite.WhereNullMod[Q, int32]
	MinutesAwake   sqlite.WhereNullMod[Q, int32]
	Raw            sqlite.WhereNullMod[Q, string]
}

func (sleepLogWhere[Q]) AliasedAs(alias string) sleepLogWhere[Q] {
	return buildSleepLogWhere[Q](buildSleepLogColumns(alias))
}

func buildSleepLogWhere[Q sqlite.Filterable](cols sleepLogColumns) sleepLogWhere[Q] {
	return sleepLogWhere[Q]{
		ID:             sqlite.Where[Q, int32](cols.ID),
		DayID:          sqlite.Where[Q, int32](cols.DayID),
		Date:           sqlite.Where[Q, time.Time](cols.Date),
		StartTime:      sqlite.Where[Q, time.Time](cols.StartTime),
		EndTime:        sqlite.Where[Q, time.Time](cols.EndTime),
		IsMainSleep:    sqlite.WhereNull[Q, bool](cols.IsMainSleep),
		IsAutomated:    sqlite.WhereNull[Q, bool](cols.IsAutomated),
		Origin:         sqlite.Where[Q, string](cols.Origin),
		TotalTimeInBed: sqlite.WhereNull[Q, int32](cols.TotalTimeInBed),
		MinutesAsleep:  sqlite.WhereNull[Q, int32](cols.MinutesAsleep),
		MinutesRem:     sqlite.WhereNull[Q, int32](cols.MinutesRem),
		MinutesDeep:    sqlite.WhereNull[Q, int32](cols.MinutesDeep),
		MinutesLight:   sqlite.WhereNull[Q, int32](cols.MinutesLight),
		MinutesAwake:   sqlite.WhereNull[Q, int32](cols.MinutesAwake),
		Raw:            sqlite.WhereNull[Q, string](cols.Raw),
	}
}

type sleepLogJoins[Q dialect.Joinable] struct {
	typ string
	Day func(context.Context) modAs[Q, dayColumns]
}

func (j sleepLogJoins[Q]) aliasedAs(alias string) sleepLogJoins[Q] {
	return buildSleepLogJoins[Q](buildSleepLogColumns(alias), j.typ)
}

func buildSleepLogJoins[Q dialect.Joinable](cols sleepLogColumns, typ string) sleepLogJoins[Q] {
	return sleepLogJoins[Q]{
		typ: typ,
		Day: sleepLogsJoinDay[Q](cols, typ),
	}
}

// FindSleepLog retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindSleepLog(ctx context.Context, exec bob.Executor, IDPK int32, cols ...string) (*SleepLog, error) {
	if len(cols) == 0 {
		return SleepLogs.Query(
			ctx, exec,
			SelectWhere.SleepLogs.ID.EQ(IDPK),
		).One()
	}

	return SleepLogs.Query(
		ctx, exec,
		SelectWhere.SleepLogs.ID.EQ(IDPK),
		sm.Columns(SleepLogs.Columns().Only(cols...)),
	).One()
}

// SleepLogExists checks the presence of a single record by primary key
func SleepLogExists(ctx context.Context, exec bob.Executor, IDPK int32) (bool, error) {
	return SleepLogs.Query(
		ctx, exec,
		SelectWhere.SleepLogs.ID.EQ(IDPK),
	).Exists()
}

// PrimaryKeyVals returns the primary key values of the SleepLog
func (o *SleepLog) PrimaryKeyVals() bob.Expression {
	return sqlite.Arg(o.ID)
}

// Update uses an executor to update the SleepLog
func (o *SleepLog) Update(ctx context.Context, exec bob.Executor, s *SleepLogSetter) error {
	return SleepLogs.Update(ctx, exec, s, o)
}

// Delete deletes a single SleepLog record with an executor
func (o *SleepLog) Delete(ctx context.Context, exec bob.Executor) error {
	return SleepLogs.Delete(ctx, exec, o)
}

// Reload refreshes the SleepLog using the executor
func (o *SleepLog) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := SleepLogs.Query(
		ctx, exec,
		SelectWhere.SleepLogs.ID.EQ(o.ID),
	).One()
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

func (o SleepLogSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals SleepLogSetter) error {
	return SleepLogs.Update(ctx, exec, &vals, o...)
}

func (o SleepLogSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	return SleepLogs.Delete(ctx, exec, o...)
}

func (o SleepLogSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	var mods []bob.Mod[*dialect.SelectQuery]

	IDPK := make([]int32, len(o))

	for i, o := range o {
		IDPK[i] = o.ID
	}

	mods = append(mods,
		SelectWhere.SleepLogs.ID.In(IDPK...),
	)

	o2, err := SleepLogs.Query(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, old := range o {
		for _, new := range o2 {
			if new.ID != old.ID {
				continue
			}
			new.R = old.R
			*old = *new
			break
		}
	}

	return nil
}

func sleepLogsJoinDay[Q dialect.Joinable](from sleepLogColumns, typ string) func(context.Context) modAs[Q, dayColumns] {
	return func(ctx context.Context) modAs[Q, dayColumns] {
		return modAs[Q, dayColumns]{
			c: DayColumns,
			f: func(to dayColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Days.Name(ctx).As(to.Alias())).On(
						to.ID.EQ(from.DayID),
					))
				}

				return mods
			},
		}
	}
}

// Day starts a query for related objects on days
func (o *SleepLog) Day(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) DaysQuery {
	return Days.Query(ctx, exec, append(mods,
		sm.Where(DayColumns.ID.EQ(sqlite.Arg(o.DayID))),
	)...)
}

func (os SleepLogSlice) Day(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) DaysQuery {
	PKArgs := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgs[i] = sqlite.ArgGroup(o.DayID)
	}

	return Days.Query(ctx, exec, append(mods,
		sm.Where(sqlite.Group(DayColumns.ID).In(PKArgs...)),
	)...)
}

func (o *SleepLog) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "Day":
		rel, ok := retrieved.(*Day)
		if !ok {
			return fmt.Errorf("sleepLog cannot load %T as %q", retrieved, name)
		}

		o.R.Day = rel

		if rel != nil {
			rel.R.SleepLogs = SleepLogSlice{o}
		}
		return nil
	default:
		return fmt.Errorf("sleepLog has no relationship %q", name)
	}
}

func PreloadSleepLogDay(opts ...sqlite.PreloadOption) sqlite.Preloader {
	return sqlite.Preload[*Day, DaySlice](orm.Relationship{
		Name: "Day",
		Sides: []orm.RelSide{
			{
				From: "sleep_logs",
				To:   TableNames.Days,
				ToExpr: func(ctx context.Context) bob.Expression {
					return Days.Name(ctx)
				},
				FromColumns: []string{
					ColumnNames.SleepLogs.DayID,
				},
				ToColumns: []string{
					ColumnNames.Days.ID,
				},
			},
		},
	}, Days.Columns().Names(), opts...)
}

func ThenLoadSleepLogDay(queryMods ...bob.Mod[*dialect.SelectQuery]) sqlite.Loader {
	return sqlite.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadSleepLogDay(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load SleepLogDay", retrieved)
		}

		err := loader.LoadSleepLogDay(ctx, exec, queryMods...)

		// Don't cause an issue due to missing relationships
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}

		return err
	})
}

// LoadSleepLogDay loads the sleepLog's Day into the .R struct
func (o *SleepLog) LoadSleepLogDay(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Day = nil

	related, err := o.Day(ctx, exec, mods...).One()
	if err != nil {
		return err
	}

	related.R.SleepLogs = SleepLogSlice{o}

	o.R.Day = related
	return nil
}

// LoadSleepLogDay loads the sleepLog's Day into the .R struct
func (os SleepLogSlice) LoadSleepLogDay(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	days, err := os.Day(ctx, exec, mods...).All()
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range days {
			if o.DayID != rel.ID {
				continue
			}

			rel.R.SleepLogs = append(rel.R.SleepLogs, o)

			o.R.Day = rel
			break
		}
	}

	return nil
}

func attachSleepLogDay0(ctx context.Context, exec bob.Executor, count int, sleepLog0 *SleepLog, day1 *Day) (*SleepLog, error) {
	setter := &SleepLogSetter{
		DayID: omit.From(day1.ID),
	}

	err := SleepLogs.Update(ctx, exec, setter, sleepLog0)
	if err != nil {
		return nil, fmt.Errorf("attachSleepLogDay0: %w", err)
	}

	return sleepLog0, nil
}

func (sleepLog0 *SleepLog) InsertDay(ctx context.Context, exec bob.Executor, related *DaySetter) error {
	day1, err := Days.Insert(ctx, exec, related)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachSleepLogDay0(ctx, exec, 1, sleepLog0, day1)
	if err != nil {
		return err
	}

	sleepLog0.R.Day = day1

	day1.R.SleepLogs = append(day1.R.SleepLogs, sleepLog0)

	return nil
}

func (sleepLog0 *SleepLog) AttachDay(ctx context.Context, exec bob.Executor, day1 *Day) error {
	var err error

	_, err = attachSleepLogDay0(ctx, exec, 1, sleepLog0, day1)
	if err != nil {
		return err
	}

	sleepLog0.R.Day = day1

	day1.R.SleepLogs = append(day1.R.SleepLogs, sleepLog0)

	return nil
}
